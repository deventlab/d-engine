// This file is @generated by prost-build.
/// Basic definitions shared across modules
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LogId {
    #[prost(uint64, tag = "1")]
    pub term: u64,
    #[prost(uint64, tag = "2")]
    pub index: u64,
}
/// Raft log entry
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
    #[prost(uint64, tag = "1")]
    pub index: u64,
    #[prost(uint64, tag = "2")]
    pub term: u64,
    #[prost(message, optional, tag = "3")]
    pub payload: ::core::option::Option<EntryPayload>,
}
/// Log entry payload
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryPayload {
    #[prost(oneof = "entry_payload::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<entry_payload::Payload>,
}
/// Nested message and enum types in `EntryPayload`.
pub mod entry_payload {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// No operation (internal to the protocol)
        #[prost(message, tag = "1")]
        Noop(super::Noop),
        /// Business write operation
        #[prost(bytes, tag = "2")]
        Command(::prost::alloc::vec::Vec<u8>),
        /// Cluster configuration change
        #[prost(message, tag = "3")]
        Config(super::MembershipChange),
    }
}
/// Internal operation of the protocol
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Noop {}
/// Cluster configuration change
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipChange {
    #[prost(oneof = "membership_change::Change", tags = "1, 2, 3, 4")]
    pub change: ::core::option::Option<membership_change::Change>,
}
/// Nested message and enum types in `MembershipChange`.
pub mod membership_change {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Change {
        #[prost(message, tag = "1")]
        AddNode(super::AddNode),
        #[prost(message, tag = "2")]
        RemoveNode(super::RemoveNode),
        #[prost(message, tag = "3")]
        Promote(super::PromoteLearner),
        #[prost(message, tag = "4")]
        BatchPromote(super::BatchPromote),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddNode {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveNode {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromoteLearner {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
    #[prost(enumeration = "NodeStatus", tag = "2")]
    pub status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPromote {
    #[prost(uint32, repeated, tag = "1")]
    pub node_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "NodeStatus", tag = "2")]
    pub new_status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotEntry {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnapshotMeta {
    #[prost(uint64, tag = "1")]
    pub version_high: u64,
    #[prost(uint64, tag = "2")]
    pub version_low: u64,
    #[prost(uint64, tag = "3")]
    pub created_at_high: u64,
    #[prost(uint64, tag = "4")]
    pub created_at_low: u64,
    #[prost(uint32, tag = "5")]
    pub author_id: u32,
    #[prost(message, optional, tag = "6")]
    pub last_included: ::core::option::Option<LogId>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<SnapshotMeta>,
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<SnapshotEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeStatus {
    /// Initial joining process
    ///
    /// New node, catching up with logs
    Joining = 0,
    /// Start syncing with leader committed logs
    Syncing = 1,
    /// Running status
    ///
    /// Formal voting member
    Active = 2,
    /// Disaster recovery ready node (data has been synchronized)
    StandBy = 3,
    /// Offline process
    ///
    /// Prepare to go offline (not accepting new requests, transfer data)
    Draining = 4,
    /// Retiring (data migration completed)
    Retiring = 5,
}
impl NodeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Joining => "JOINING",
            Self::Syncing => "SYNCING",
            Self::Active => "ACTIVE",
            Self::StandBy => "STAND_BY",
            Self::Draining => "DRAINING",
            Self::Retiring => "RETIRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOINING" => Some(Self::Joining),
            "SYNCING" => Some(Self::Syncing),
            "ACTIVE" => Some(Self::Active),
            "STAND_BY" => Some(Self::StandBy),
            "DRAINING" => Some(Self::Draining),
            "RETIRING" => Some(Self::Retiring),
            _ => None,
        }
    }
}
