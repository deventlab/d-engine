// This file is @generated by prost-build.
/// Basic definitions shared across modules
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LogId {
    #[prost(uint64, tag = "1")]
    pub term: u64,
    #[prost(uint64, tag = "2")]
    pub index: u64,
}
/// Raft log entry
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
    #[prost(uint64, tag = "1")]
    pub index: u64,
    #[prost(uint64, tag = "2")]
    pub term: u64,
    #[prost(message, optional, tag = "3")]
    pub payload: ::core::option::Option<EntryPayload>,
}
/// Log entry payload
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryPayload {
    #[prost(oneof = "entry_payload::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<entry_payload::Payload>,
}
/// Nested message and enum types in `EntryPayload`.
pub mod entry_payload {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// No operation (internal to the protocol)
        #[prost(message, tag = "1")]
        Noop(super::Noop),
        /// Business write operation
        #[prost(bytes, tag = "2")]
        Command(::prost::bytes::Bytes),
        /// Cluster configuration change
        #[prost(message, tag = "3")]
        Config(super::MembershipChange),
    }
}
/// Internal operation of the protocol
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Noop {}
/// Cluster configuration change
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipChange {
    #[prost(oneof = "membership_change::Change", tags = "1, 2, 3, 4, 5")]
    pub change: ::core::option::Option<membership_change::Change>,
}
/// Nested message and enum types in `MembershipChange`.
pub mod membership_change {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Change {
        #[prost(message, tag = "1")]
        AddNode(super::AddNode),
        #[prost(message, tag = "2")]
        RemoveNode(super::RemoveNode),
        #[prost(message, tag = "3")]
        Promote(super::PromoteLearner),
        #[prost(message, tag = "4")]
        BatchPromote(super::BatchPromote),
        #[prost(message, tag = "5")]
        BatchRemove(super::BatchRemove),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddNode {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveNode {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromoteLearner {
    #[prost(uint32, tag = "1")]
    pub node_id: u32,
    #[prost(enumeration = "NodeStatus", tag = "2")]
    pub status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPromote {
    #[prost(uint32, repeated, tag = "1")]
    pub node_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "NodeStatus", tag = "2")]
    pub new_status: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchRemove {
    #[prost(uint32, repeated, tag = "1")]
    pub node_ids: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotEntry {
    #[prost(bytes = "bytes", tag = "1")]
    pub key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnapshotMeta {
    #[prost(uint64, tag = "1")]
    pub version_high: u64,
    #[prost(uint64, tag = "2")]
    pub version_low: u64,
    #[prost(uint64, tag = "3")]
    pub created_at_high: u64,
    #[prost(uint64, tag = "4")]
    pub created_at_low: u64,
    #[prost(uint32, tag = "5")]
    pub author_id: u32,
    #[prost(message, optional, tag = "6")]
    pub last_included: ::core::option::Option<LogId>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<SnapshotMeta>,
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<SnapshotEntry>,
}
/// Leader election information
/// Used at: Application layer (internal Raft protocol notifications)
/// Purpose: Notify applications about leader changes via watch channel
/// Fields: Minimal - only what Raft protocol needs
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeaderInfo {
    /// Current leader node ID
    #[prost(uint32, tag = "1")]
    pub leader_id: u32,
    /// Current Raft term
    #[prost(uint64, tag = "2")]
    pub term: u64,
}
/// Leader hint for client redirection
/// Used at: Network layer (gRPC error responses)
/// Purpose: Help clients redirect requests to the current leader
/// Fields: Includes network address for immediate retry
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderHint {
    /// Current leader node ID
    #[prost(uint32, tag = "1")]
    pub leader_id: u32,
    /// Leader's network address (e.g., "127.0.0.1:5001")
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeStatus {
    /// Initial joining process
    ///
    /// New node, catching up with logs
    Joining = 0,
    /// Start syncing with leader committed logs
    Syncing = 1,
    /// Running status
    ///
    /// Formal voting member
    Active = 2,
    /// Disaster recovery ready node (data has been synchronized)
    StandBy = 3,
    /// Offline process
    ///
    /// Prepare to go offline (not accepting new requests, transfer data)
    Draining = 4,
    /// Retiring (data migration completed)
    Retiring = 5,
    /// Zombie node (removed from cluster)
    Zombie = 6,
}
impl NodeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Joining => "JOINING",
            Self::Syncing => "SYNCING",
            Self::Active => "ACTIVE",
            Self::StandBy => "STAND_BY",
            Self::Draining => "DRAINING",
            Self::Retiring => "RETIRING",
            Self::Zombie => "ZOMBIE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOINING" => Some(Self::Joining),
            "SYNCING" => Some(Self::Syncing),
            "ACTIVE" => Some(Self::Active),
            "STAND_BY" => Some(Self::StandBy),
            "DRAINING" => Some(Self::Draining),
            "RETIRING" => Some(Self::Retiring),
            "ZOMBIE" => Some(Self::Zombie),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeRole {
    Follower = 0,
    Candidate = 1,
    Leader = 2,
    Learner = 3,
}
impl NodeRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Follower => "FOLLOWER",
            Self::Candidate => "CANDIDATE",
            Self::Leader => "LEADER",
            Self::Learner => "LEARNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FOLLOWER" => Some(Self::Follower),
            "CANDIDATE" => Some(Self::Candidate),
            "LEADER" => Some(Self::Leader),
            "LEARNER" => Some(Self::Learner),
            _ => None,
        }
    }
}
