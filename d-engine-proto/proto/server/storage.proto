syntax = "proto3";
package d_engine.server.storage;

import "proto/common.proto";

message SnapshotChunk {
    // Leader's current term (for leadership validation)
    uint64 leader_term = 1;

    // Leader's node ID (for identification)
    uint32 leader_id = 2;

    // Chunk sequence number (0-based)
    uint32 seq = 3;

    // Total number of chunks in this snapshot
    uint32 total_chunks = 4;

    // Chunk-specific checksum (CRC32)
    bytes chunk_checksum = 5;

    // Snapshot metadata (only present in first chunk)
    optional SnapshotMetadata metadata = 6;

    // Payload data (recommended 4MB chunks)
    bytes data = 7;
}

message SnapshotMetadata {
    d_engine.common.LogId last_included = 1; // The last log index included in the snapshot
    bytes checksum = 2;             // SHA-256 checksum// Total number of chunks in this snapshot
}

message SnapshotResponse {
    uint64 term = 1; // Peer's current term (for Leader degradation detection)
    bool success = 2; // Whether the reception is successful
    uint32 next_chunk = 3; // If failed, specify the chunk index to be retransmitted
}

message PurgeLogRequest {
    uint64 term = 1;
    uint32 leader_id = 2;
    uint64 leader_commit = 3; // Leader's commit_index (for Peer verification)
    d_engine.common.LogId last_included = 4; // Maximum log index that can be deleted
    bytes snapshot_checksum = 5;
}

message PurgeLogResponse {
    uint32 node_id = 1;
    uint64 term = 2; // Peer's current term (for Leader abdication)
    bool success = 3; // Whether to accept the request (non-asynchronous operation result)
    d_engine.common.LogId last_purged = 4; // Peer's current purged position (for Leader update progress)
}


message SnapshotAck {
  // Received chunk sequence number
  uint32 seq = 1;

  // Status of this chunk
  ChunkStatus status = 2;

  // Next requested chunk (for flow control)
  uint32 next_requested = 3;

  enum ChunkStatus {
    ACCEPTED = 0;
    CHECKSUM_MISMATCH = 1;
    OUT_OF_ORDER = 2;
    REQUESTED = 3;
    FAILED = 4;
  }
}

service SnapshotService {
  // Leader-driven snapshot streaming
  rpc InstallSnapshot(stream SnapshotChunk) returns (SnapshotResponse);

  // Learner-driven snapshot streaming
  rpc StreamSnapshot(stream SnapshotAck) returns (stream SnapshotChunk);

  // Log compaction request
  rpc PurgeLog(PurgeLogRequest) returns (PurgeLogResponse);
}
